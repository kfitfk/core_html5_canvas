<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Dragging Bezier Curve</title>
	<style type="text/css">
	body {
		background: #eee;
	}

	.floatingControls {
		position: absolute;
		left: 150px;
		top: 100px;
		width: 300px;
		padding: 20px;
		border: thin solid rgba(0,0,0,0.3);
		background: rgb(0,0,200,0.1);
		color: blue;
		-webkit-box-shadow: 6px 6px 8px rgba(0,0,0,0.2);
		-moz-box-shadow: 6px 6px 8px rgba(0,0,0,0.2);
		box-shadow: 6px 6px 8px rgba(0,0,0,0.2);
		display: none;
	}

	.floatingControls p {
		margin-top: 0;
		margin-bottom: 20px;
	}

	#controls {
		position: absolute;
		left: 25px;
		top: 25px;
	}
	#canvas {
		background: #fff;
		cursor: crosshair;
		margin: 10px 0 0 10px;
		-webkit-box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
		-moz-box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
		box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
	}
	</style>
</head>
<body>
<canvas id="canvas" width="800" height="540"></canvas>
<div id="controls">
	Stroke color: <select name="" id="strokeStyleSelect">
		<option value="red">red</option>
		<option value="green">green</option>
		<option value="blue">blue</option>
		<option value="orange">orange</option>
		<option value="cornflowerblue">conflowerblue</option>
		<option value="goldenrod">goldenrod</option>
		<option value="navy">navy</option>
		<option value="purple">purple</option>
	</select>

	Guidewires:
	<input type="checkbox" id="guidewireCheckbox" checked="checked">
	<input type="button" id="eraseAllButton" value="Erase All">
</div>
<div id="instructions" class="floatingControls">
	<p>Drag the curve end- and control points to change the shape of the curve.</p>
	<p>When you are done dragging end- and control points, click outside of the points to finalize the curve.</p>
	<input type="button" id="instructionsOkayButton" value="Okay" autoFocus>
	<input type="button" id="instructionsNoMoreButton" value="Do not show these instructions again">
</div>
</body>
<script type="text/javascript" src="shared/polygon.js"></script>
<script type="text/javascript">
var cvs = document.getElementById('canvas'),
	ctx = cvs.getContext('2d'),
	eraseAllButton = document.getElementById('eraseAllButton'),
	strokeStyleSelect = document.getElementById('strokeStyleSelect'),
	guidewireCheckbox = document.getElementById('guidewireCheckbox'),
	instructions = document.getElementById('instructions'),
	instructionsOkayButton = document.getElementById('instructionsOkayButton'),
	instructionsNoMoreButton = document.getElementById('instructionsNoMoreButton'),

	showInstructions = true,

	AXIS_MARGIN = 40,
	HORIZONTAL_TICK_SPACING = 10,
	VERTICAL_TICK_SPACING = 10,
	TICK_SIZE = 10,

	AXIS_ORIGIN = { x : AXIS_MARGIN, y : cvs.height - AXIS_MARGIN },
	AXIS_TOP = AXIS_MARGIN,
	AXIS_RIGHT = cvs.width - AXIS_MARGIN,
	AXIS_WIDTH = AXIS_RIGHT - AXIS_ORIGIN.x,
	AXIS_HEIGHT = AXIS_ORIGIN.y - AXIS_TOP,

	NUM_VERTICAL_TICKS = AXIS_HEIGHT / VERTICAL_TICK_SPACING,
	NUM_HORIZONTAL_TICKS = AXIS_WIDTH / HORIZONTAL_TICK_SPACING,

	GRID_SROKE_STYLE = 'lightblue',
	GRID_SPACING = 10,

	CONTROL_POINT_RADIUS = 5,
	CONTROL_POINT_STROKE_STYLE = 'blue',
	CONTROL_POINT_FILL_STYLE = 'rgba(255,255,0,0.5)',

	END_POINT_STROKE_STYLE = 'navy',
	END_POINT_FILL_STYLE = 'rgba(0,255,0,0.5)',

	GUIDEWIRE_STROKE_STYLE = 'rgba(0,0,230,0.4)',

	drawingSurfaceImageData,

	mousedown = {},
	rubberbandRect = {},

	dragging = false,
	draggingPoint = false,

	endPoints = [{}, {}],
	controlPoints = [{}, {}],
	editing = false,

	guidewires = guidewireCheckbox.checked;

function drawGrid (ctx, color, stepx, stepy) {
	ctx.save();
	ctx.strokeStyle = color;
	ctx.lineWidth = 0.5;

	for(var i = stepx + 0.5; i < ctx.canvas.width; i += stepx) {
		ctx.beginPath();
		ctx.moveTo(i, 0);
		ctx.lineTo(i, ctx.canvas.height);
		ctx.stroke();
	}

	for(var i = stepy + 0.5; i < ctx.canvas.height; i += stepy) {
		ctx.beginPath();
		ctx.moveTo(0, i);
		ctx.lineTo(ctx.canvas.width, i);
		ctx.stroke();
	}
	ctx.restore();
}

function windowToCanvas (x, y) {
	var bbox = cvs.getBoundingClientRect();
	return {
		x : x - bbox.left * (cvs.width / bbox.width),
		y : y - bbox.top  * (cvs.height/ bbox.height)
	}
}

// save and restore drawing surface
function saveDrawingSurface () {
	drawingSurfaceImageData = ctx.getImageData(0, 0, cvs.width, cvs.height);
}

function restoreDrawingSurface () {
	ctx.putImageData(drawingSurfaceImageData, 0, 0);
}

// Rubber bands
function updateRubberbandRectangle (loc) {
	rubberbandRect.width = Math.abs(loc.x - mousedown.x);
	rubberbandRect.height = Math.abs(loc.y - mousedown.y);

	if(loc.x > mousedown.x) { rubberbandRect.left = mousedown.x; }
	else { rubberbandRect.left = loc.x; }

	if(loc.y > mousedown.y) { rubberbandRect.top = mousedown.y; }
	else { rubberbandRect.top = loc.y; }
}

function drawBezierCurve () {
	ctx.beginPath();
	ctx.moveTo(endPoints[0].x, endPoints[0].y);
	ctx.bezierCurveTo(controlPoints[0].x, controlPoints[0].y,
		              controlPoints[1].x, controlPoints[1].y,
		              endPoints[1].x, endPoints[1].y);
	ctx.stroke();
}

function updateEndAndControlPoints () {
	endPoints[0].x = rubberbandRect.left;
	endPoints[0].y = rubberbandRect.top;

	endPoints[1].x = rubberbandRect.left + rubberbandRect.width;
	endPoints[1].y = rubberbandRect.top + rubberbandRect.height;

	controlPoints[0].x = rubberbandRect.left;
	controlPoints[0].y = rubberbandRect.top + rubberbandRect.height;

	controlPoints[1].x = rubberbandRect.left + rubberbandRect.width;
	controlPoints[1].y = rubberbandRect.top;
}

function drawRubberbandShape (loc) {
	updateEndAndControlPoints();
	drawBezierCurve();
}

function updateRubberband (loc) {
	updateRubberbandRectangle(loc);
	drawRubberbandShape(loc);
}

// Guidewires
function drawHorizontalLine(y) {
	ctx.beginPath();
	ctx.moveTo(0, y + 0.5);
	ctx.lineTo(ctx.canvas.width, y + 0.5);
	ctx.stroke();
}

function drawVerticalLine(x) {
	ctx.beginPath();
	ctx.moveTo(x + 0.5, 0);
	ctx.lineTo(x + 0.5, ctx.canvas.height);
	ctx.stroke();
}

function drawGuidewires (x, y) {
	ctx.save();
	ctx.strokeStyle = GUIDEWIRE_STROKE_STYLE;
	ctx.lineWidth = 0.5;
	drawVerticalLine(x);
	drawHorizontalLine(y);
	ctx.restore();
}

// End points and control points
function drawControlPoint (index) {
	ctx.beginPath();
	ctx.arc(controlPoints[index].x, controlPoints[index].y, CONTROL_POINT_RADIUS, 0, 2*Math.PI, false);
	ctx.stroke();
	ctx.fill();
}

function drawControlPoints () {
	ctx.save();
	ctx.strokeStyle = CONTROL_POINT_STROKE_STYLE;
	ctx.fillStyle = CONTROL_POINT_FILL_STYLE;
	drawControlPoint(0);
	drawControlPoint(1);
	// ctx.stroke();
	// ctx.fill();
	ctx.restore();
}

function drawEndPoint (index) {
	ctx.beginPath();
	ctx.arc(endPoints[index].x, endPoints[index].y, CONTROL_POINT_RADIUS, 0, 2*Math.PI, false);
	ctx.stroke();
	ctx.fill();
}

function drawEndPoints () {
	ctx.save();
	ctx.strokeStyle = END_POINT_STROKE_STYLE;
	ctx.fillStyle = END_POINT_FILL_STYLE;
	drawEndPoint(0);
	drawEndPoint(1);
	// ctx.stroke();
	// ctx.fill();
	ctx.restore();
}

function drawControlAndEndPoints () {
	drawControlPoints();
	drawEndPoints();
}

function cursorInEndPoint (loc) {
	var pt;

	endPoints.forEach(function(point) {
		ctx.beginPath();
		ctx.arc(point.x, point.y, CONTROL_POINT_RADIUS, 0, Math.PI*2, false);

		if(ctx.isPointInPath(loc.x, loc.y)) {
			pt = point;
		}
	});

	return pt;
}

function cursorInControlPoint (loc) {
	var pt;

	controlPoints.forEach(function(point) {
		ctx.beginPath();
		ctx.arc(point.x, point.y, CONTROL_POINT_RADIUS, 0, Math.PI*2, false);

		if(ctx.isPointInPath(loc.x, loc.y)) {
			pt = point;
		}
	});

	return pt;
}

function updateDraggingPoint (loc) {
	draggingPoint.x = loc.x;
	draggingPoint.y = loc.y;
}

// Canvas event handlers
cvs.onmousedown = function(e) {
	var loc = windowToCanvas(e.clientX, e.clientY);

	e.preventDefault();  // prevent cursor change
	if(!editing) {
		saveDrawingSurface();
		mousedown.x = loc.x;
		mousedown.y = loc.y;
		updateRubberbandRectangle(loc);
		dragging = true;
	} else {
		draggingPoint = cursorInControlPoint(loc);

		if(!draggingPoint) {
			draggingPoint = cursorInEndPoint(loc);
		}
	}
};

cvs.onmousemove = function(e) {
	var loc = windowToCanvas(e.clientX, e.clientY);

	if(dragging || draggingPoint) {
		e.preventDefault(); // Prevent selections
		restoreDrawingSurface();

		if(guidewires) {
			drawGuidewires(loc.x, loc.y);
		}
	}

	if(dragging) {
		updateRubberband(loc);
		drawControlAndEndPoints();
	} else if(draggingPoint) {
		updateDraggingPoint(loc);
		drawControlAndEndPoints();
		drawBezierCurve();
	}
};

cvs.onmouseup = function(e) {
	var loc = windowToCanvas(e.clientX, e.clientY);

	restoreDrawingSurface();

    if(!editing) {
		updateRubberband(loc);
		drawControlAndEndPoints();
		dragging = false;
		editing = true;
		if(showInstructions) {
			instructions.style.display = 'inline';
		}
    } else {
    	if(draggingPoint) { drawControlAndEndPoints(); }
    	else { editing = false; }

    	drawBezierCurve();
    	draggingPoint = undefined;
    }
};

// Controls event handlers
eraseAllButton.onclick = function(e) {
	ctx.clearRect(0, 0, cvs.width, cvs.height);
	drawGrid(ctx, GRID_SROKE_STYLE, GRID_SPACING, GRID_SPACING);
	saveDrawingSurface();

	editing = false;
	dragging = false;
	draggingPoint = undefined;
};

strokeStyleSelect.onchange = function(e) {
	ctx.strokeStyle = strokeStyleSelect.value;
};

guidewireCheckbox.onchange = function(e) {
	guidewires = guidewireCheckbox.value;
}
// Instructions event handlers
instructionsOkayButton.onclick = function(e) {
	instructions.style.display = 'none';
};

instructionsNoMoreButton.onclick = function(e) {
	instructions.style.display = 'none';
	showInstructions = false;
}

// Initialization
ctx.strokeStyle = strokeStyleSelect.value;
drawGrid(ctx, GRID_SROKE_STYLE, GRID_SPACING, GRID_SPACING);
</script>
</html>